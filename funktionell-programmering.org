#+TITLE: Funktionell Programmering
#+AUTHOR: Victor Albertsson
#+OPTIONS: toc:nil num:nil
* Problem med imperativ programmering
  - Skapar svårfångade buggar
  - Svårt att optimera
    - Samtidighet
    - Parallelism
  - Problem med minnessäkerhet
* Grundläggande principer
** Oföränderlighet
   # #+BEGIN_NOTES
   # - Inge loopar
   # - Inga arrays (fält)
   # - Inga configurationsvariabler
   # #+END_NOTES
   - Variabler och funktioner kan endast initieras (!)
** Funktioner hela vägen ner
   # #+BEGIN_NOTES
   # - Inga speciella satser, endast funktioner
   # #+END_NOTES
   - Program ska delas in i många små funktioner
   - Funktioner konstrueras från mindre funktioner utan att deras betydelse ändras
   #+BEGIN_SRC racket
     #lang racket
     (require racket/function)
     ((curry + 10) 20) ; = (+ 10 20)
     ;; 30

     (map (curry + 10) (list 20 40 60))
     ;; '(30 50 70)

     ((compose sqrt +) 16 9)
     ;; 5
   #+END_SRC
** Induktiva typer
   - Rekursiva funktioner blir ett naturlig verktyg
   - Även ‘pattern matching’ blir möjligt
   #+BEGIN_SRC racket
     #lang typed/racket
     (define-type (List A) (Rec List (Pair A (U List Null))))
     ;; ‘Rec’ skapar en anonym datatyp
   #+END_SRC
* Konsekvenser
** Matematiska resonemang
   - /"If it is to be effective as a tool of thought, a notation must allow convenient expression not only of notions arising directly from a problem, but also of those arising in subsequent analysis, generalization, and specialization."/ -- Kenneth E. Iverson
   - Typer som propositioner och funktioner av typer som bevis
   - Verifiering av kodsäkerhet blir möjligt
** Starkare optimering
   - Samtidighet (Erlang)
   - Parallelism (APL)
** Modularitet
   - Eliminering av kopplingar mellan orelaterad kod
   - Alla värden som en funktion kan anta måste vara väldefinierade
** Rekursion
   - Kan skapa eleganta lösningar
   - Kräver mer kognitiv ansträngning i tidskritiska applikationer
   - Effektiv rekursion kräver att språket stödjer vissa optimeringsstrategier (tail-call elimination)
* Deklarativ programmering
  - *VAD* som ska göras utan *HUR* det ska utföras
** Prolog ([[https://www.youtube.com/channel/UCFFeNyzCEQDS4KCecugmotg][The Power of Prolog]])
   #+BEGIN_SRC prolog
     :- use_module(library(reif)).

     list_without([], _, []).
     list_without([X|Xs], E, Ys) :-
	 if_(X=E, Ys=Ls, Ys=[X|Ls]),
	 list_without(Xs, E, Ls).
   #+END_SRC
** Den deklarativa hierarkin
   | Endast reversibla funktioner | Monoton                           |
   | Inga mutationer              | Icke-monoton, Rent funktionell    |
   | Begränsade mutationer        | Monadisk, Substrukturell et al    |
   | Obegränsade mutationer       | Imperativ                         |
* Fin
